# Диамантен проблем
```c++
/*
        A
       / \
      B   C
       \ /
        D
*/

class A {
public:
    //...
    int a;
};

class B: public A {
public:
    //...
    int b;
}

class C: public A {
public:
    //...
    int c;
}

class D : public B, public C {
public:
   //...
   int d;
}
```

- При създаването на обект от тип `A`, се инициализира член-данна `a` с конструктора на `A`:
    ```c++
    A() { a = 1; }
    ```
- При създаването на обект от тип `B`, се инициализират член-данна `a` с конструктора на `A` и член-данна `B` с конструктора на `B`:    
    ```c++
    B() : A() { b = 2; }
    ```
- При създаването на обект от тип `B`, се инициализират член-данна `a` с конструктора на `A` и член-данна `C` с конструктора на `C`:        
    ```c++
    C() : A() { c = 3; }
    ```
- При създаването на обект от тип `D`, се инициализират член-данна `b` с конструктора на `B`, член-данна `c`с конструктора на `C` и член-данна `a` два пъти - веднъж през `B()`, веднъж през `C()`: 
    ```c++
    D() : B(), C() { d = 4; }
    //Данните на обект от тип D: 
    // а, а, b, c, d 
    // Когато искаме да използваме a -> проблем - кое a точно искаме?
    ```

## Решение на проблема
- [Виртуално наследяване](https://en.wikipedia.org/wiki/Virtual_inheritance)           
- Всички класове, които наследяват виртуално, имат [виртуална таблица](https://shaharmike.com/cpp/vtable-part3/)

```c++
class A {
    //...
};

class B: virtual public A {
    //...
}

class C: virtual public A {
    //...
}

class D : public B, public C {
public:
   //...
}
```
### pure virtual functions
- Ако в `A` има чисто виртуална функция и `B` и `C` наследяват виртуално, не са задължени да override-ват функцията.
- Ако `D` не наследява `B` и `C` виртуално, е задължен да override-не чисто виртуалната функция от `A`

### Конструктори на D
- Без параметри: 
    ```c++
    D() : B(), C() { // Викат се B() и C(), но не викат A() 2 пъти, а само веднъж
        //...
    }
    ```
    ```c++
    D : A(), B(), C() { // Същото
        //...
    }
    ```
- С параметри: 
    ```c++
    D(int x) : B(x + 1), C(x + 2) { // Викат се B(int), C(int) и веднъж ДЕФОЛТНИЯ A(), а не A(int)
        d = x + 3;
    }
    ```
    ```c++
    D(int x) : А(x), B(x + 1), C(x + 2) { // Викат се A(int), B(int) и C(int)
        d = x + 3;
    }
    ```
- Копиращ: 
    ```c++
    D(const D& other) : B(other), C(other) { // Викат се B(const B&), C(const C&) и веднъж ДЕФОЛТНИЯ A(), а не A(const A&)
        d = x + 3;
    }
    ```
    ```c++
    D(const D& other) : А(other), B(other), C(other) { // Викат се A(const A&), B(const B&) и C(const C&)
        d = x + 3;
    }
    ```